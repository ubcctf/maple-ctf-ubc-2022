# rev

- we could do some challenges that are like: here's some assembly code, what does it output?
- `flag{....................}`
- to encode, go char by char from the end, xoring the current byte with the next. The encoded sequence of bytes will look like random garbage. Store the encoded flag in r8,r9,r10,r11. Write assembly code that byte by byte decodes it by doing the inverse operation.
- key here is that we don't give the competitors an executable, instead we just give them the assembly code in a text form. If the competitor is well versed, they could plug it into an `asm` statement in c or use nasm to compile it and see the output. For the less experienced competitor, they'll likely need to reverse engineer the assembly by hand, then write a python script or something to solve it. This would be good for getting folks to think about how assembly code works before diving deeper into later challenges that might involve tools like Ghidra
```assembly
mov r8,  0x...
mov r9,  0x...
mov r10, 0x...
mov r11, 0x...
```
